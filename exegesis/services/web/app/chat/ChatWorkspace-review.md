# ChatWorkspace deep-dive review

## 1. State management complexity
- `isRestoring` is cleared asynchronously after attempting session hydration; while restoration runs, `handleKeyDown` and the auto-submit effect both gate on `isRestoring`, preventing premature submissions. However, `executeChat` can still be triggered via other callers (e.g., sample question buttons) because those paths do not check `isRestoring`, so a restore-in-progress could overlap with a new request and overwrite restored state. The local `autoSubmitRef` guard resets on `initialPrompt` changes, but streaming state (`isStreaming`) is cleared in the `applyStreamEvent` guardrail branch before `setActiveAssistantId(null)`, meaning a late-arriving `complete` event after a guardrail violation would be ignored while `abortControllerRef` has been nulled, potentially leaving `isStreaming` false but the `activeAssistantId` set until the `finally` block runs. Consider centralizing request lifecycle with a single status machine to avoid interleaving restore/stream submits. 【F:exegesis/services/web/app/chat/ChatWorkspace.tsx†L265-L336】【F:exegesis/services/web/app/chat/ChatWorkspace.tsx†L481-L579】

## 2. Render performance
- The `transcript` `useMemo` derives a new array on every `conversation` or `isStreaming` change and sets a fresh `timestamp` per entry on every recompute. This defeats memoization for children because keys stay stable but props change each render, causing the entire map to rerender during high-frequency token streaming. Extracting the message list into a memoized child component that only depends on `conversation` diffs (or moving timestamps to creation time) would avoid per-token rerenders and reduce layout thrash. 【F:exegesis/services/web/app/chat/ChatWorkspace.tsx†L633-L648】【F:exegesis/services/web/app/chat/ChatWorkspace.tsx†L925-L980】

## 3. CSS architecture
- The component primarily uses the CSS module `ChatWorkspace.module.css` (`styles.*`) for layout and typography, keeping scope local. Global utility classes are only pulled in for guardrail action buttons via the string literal `"guardrail-actions"`, which relies on the global definitions in `app/globals.css`. This mixing is intentional but creates a coupling: if the module is refactored or the global class is renamed, guardrail actions silently lose styling. Converting the guardrail action layout into module-scoped styles (or re-exporting the utility via CSS module `:global`) would reduce leakage risk while keeping global utilities reserved for app-wide patterns. 【F:exegesis/services/web/app/chat/ChatWorkspace.tsx†L710-L730】【F:exegesis/services/web/app/globals.css†L1005-L1026】

## 4. Error handling and guardrail metadata
- `TheoApiError` with status 400 is translated into a guardrail object that includes structured `metadata` (codes, filters, suggested action), but the UI only renders `guardrail.message` and action buttons. The detailed metadata is neither surfaced in the `ErrorCallout` nor logged, so users cannot see why the request was blocked. Similarly, stream-time guardrail violations set `guardrail.metadata` but immediately remove the assistant entry without a user-facing explanation beyond the message string. Passing `metadata` into the `ErrorCallout` (or a detail expander) would expose actionable context; otherwise, violations effectively fail silently beyond a generic message. 【F:exegesis/services/web/app/chat/ChatWorkspace.tsx†L440-L579】【F:exegesis/services/web/app/chat/ChatWorkspace.tsx†L710-L730】
