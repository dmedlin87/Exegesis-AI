# Theo web data layer review

## 1. Client abstraction scaling
- `TheoApiClientShape` is handwritten with dozens of methods that mirror REST paths, and `createTheoApiClient` stitches together ad hoc request builders on top of a low-level `http.request` helper. This manual mapping scales linearly with each endpoint and risks drift between type declarations and implementations as the surface grows. 【F:exegesis/services/web/app/lib/api-client.ts†L1-L129】【F:exegesis/services/web/app/lib/api-client.ts†L145-L379】
- Because both the shape and each route payload are typed locally (e.g., `ResearchPlanStepUpdatePayload` translates camelCase fields to snake_case in request bodies), subtle contract changes require editing multiple spots. Generating the client from the OpenAPI spec (the repo already emits `./generated/api` types) would consolidate path definitions, HTTP verb/headers, and request/response typing in one source, reducing duplication and easing future endpoint additions. 【F:exegesis/services/web/app/lib/api-client.ts†L1-L34】【F:exegesis/services/web/app/lib/api-client.ts†L172-L220】

## 2. Data normalization and null safety
- Research-plan reads/writes consistently run through `normaliseResearchPlan`, and export flows wrap responses in `normaliseExportResponse`, giving the caller either a normalized object or an explicit error when parsing fails. 【F:exegesis/services/web/app/lib/api-client.ts†L7-L9】【F:exegesis/services/web/app/lib/api-client.ts†L155-L220】【F:exegesis/services/web/app/lib/api-client.ts†L279-L302】
- Other endpoints return raw API payloads without a normalization layer or null filtering (e.g., digest, watchlists, provider settings). If the backend returns `null` or partial data, those values propagate directly into UI components, which may assume required fields. Adding lightweight normalizers or defensive defaults for these collections would align them with the research-plan robustness and reduce downstream undefined checks. 【F:exegesis/services/web/app/lib/api-client.ts†L310-L379】

## 3. Server vs. client fetching for dashboard
- `DashboardScreen` fetches dashboard JSON on the server with `cache: "no-store"` and passes the result into the client-only `DashboardClient`, ensuring initial hydration has data but forcing a full client boundary for widget rendering. 【F:exegesis/services/web/app/dashboard/screen.tsx†L1-L24】
- Because `revalidate = 0` already marks the route as dynamic, the screen could be an RSC that streams individual widgets (or separate server components) while keeping client hooks only where interactivity is needed. That would avoid serializing the entire summary blob across the client boundary and let React reuse server data-fetch semantics per widget rather than a single prefetch plus client hydration.
